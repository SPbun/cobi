/*****************************************************************************
 **  Cobi    http://www.scalasca.org/                                       **
 *****************************************************************************
 **  Copyright (c) 2009-2010                                                **
 **  Forschungszentrum Juelich, Juelich Supercomputing Centre               **
 **                                                                         **
 **  See the file COPYRIGHT in the base directory for details               **
 *****************************************************************************/

/**
 * @file   snippetfactory.cpp
 * @author Jan Mussler
 * @brief Different SnippetFactory implementations
 *
 * Snippetfactorys transform the Boost::Spirit AST to either IExpression AST or
 * print the tree to the console
 */

#include "snippetfactories.h"
#include <sstream>

using namespace gi::generator;
using namespace gi::generator::parser;

std::string ISnippetFactory::getValueOfNode(tree_node<node_val_data<> >* node) {
    return std::string(node->value.begin(), node->value.end());
}

/**
 * Translate escaped string from specification to unescaped string
 *
 * @param s
 * @return string with all escaped chars \n \t \\ replaced by the appropriate string
 */
std::string translateEscape(std::string s) {
    size_t si;
    size_t tab;
    size_t nl;
    size_t bs;

    int nr = 0;
    string r = "";

    nl = s.find("\\n");
    bs = s.find("\\\\");
    tab = s.find("\\t");

    /**
     * select the next escaped sequence and then translate it
     */
    if (nl != s.npos && (nl < bs || bs == s.npos) && (nl < tab || tab == s.npos)) {        
        nr = 2;
        r = "\n";
        si = nl;
    }
    else if (bs != s.npos && (bs < nl || nl == s.npos) && (bs < tab || tab == s.npos)) {        
        nr = 2;
        r = "\\";
        si = bs;
    }
    else if (tab != s.npos && (tab < nl || nl == s.npos) && (tab < bs || bs == s.npos)) {        
        nr = 2;
        r = "\t";
        si = tab;
    }
    else {
        si = s.npos;
    }

    while (si != s.npos) {
        s.replace(si, nr, r);

        if(bs==si) si++; // move ahead of inserted "\" to not parse it again

        nl = s.find("\\n", si);
        bs = s.find("\\\\", si);
        tab = s.find("\\t", si);

        if (nl != s.npos && (nl < bs || bs == s.npos) && (nl < tab || tab == s.npos)) {            
            nr = 2;
            r = "\n";
            si = nl;
        }
        else if (bs != s.npos && (bs < nl || nl == s.npos) && (bs < tab || tab == s.npos)) {
            nr = 2;
            r = "\\";
            si = bs;
        }
        else if (tab != s.npos && (tab < nl || nl == s.npos) && (tab < bs || bs == s.npos)) {
            nr = 2;
            r = "\t";
            si = tab;
        }
        else {
            si = s.npos;
        }
    }

    return s;
}

/**
 * generate readable output on std::out of ast tree generated by spirit
 * @return NullOp()
 */
IExpression* DemoSnippetFactory::evaluateNode(tree_node<node_val_data<> >* node) {
    for (int i = level; i > 0; --i) {
        std::cout << "\t";
    }
    std::cout << CodeParser::getRuleNameToID(node->value.id());

    if (node->value.id() == g.identifierID) {
        std::cout << " \"" << std::string(node->value.begin(), node->value.end()) << "\"";
    }
    else if (node->value.id() == g.stringLiteralID || node->value.id() == g.intLiteralID) {
        std::string s = std::string(node->value.begin(), node->value.end());
        s = s.substr(1,s.size()-2);
        std::cout << " " << translateEscape(s);
    }
    else if (node->value.id() == g.intLiteralID) {
        std::string s = std::string(node->value.begin(), node->value.end());
        std::cout << " " << translateEscape(s);
    }
    else if (node->value.id() == g.funcParID || node->value.id() == g.contextVarID) {
        std::cout << " " << std::string(node->value.begin(), node->value.end());
    }
    else if (node->value.id() == g.boolExpressionID) {
        std::cout << " " << std::string(node->value.begin(), node->value.end());
    }
    else if (node->value.id() == g.termID) {
        std::cout << " " << std::string(node->value.begin(), node->value.end());
    }

    std::cout << "\n";

    if (node->children.size() != 0) {
        ++level;
        for (unsigned int i = 0; i < node->children.size(); ++i) {
            evaluateNode(&(node->children[i]));
        }
        --level;
    }
    return new NullOp();
}

DemoSnippetFactory::DemoSnippetFactory(codegrammar &g) : g(g), level(0) {

}

DemoSnippetFactory::~DemoSnippetFactory() {
}

Constant* SnippetFactory::evaluateConstantNode(tree_node<node_val_data<> >* node) {

    if (node->value.id() == g.stringLiteralID) {
        std::string s = getValueOfNode(node);
        s = s.substr(1,s.size()-2);
        return Constant::createConstant(translateEscape(s));
    }
    else if (node->value.id() == g.contextVarID) {
        return new ContextConstant(getValueOfNode(node));
    }
    else if (node->value.id() == g.concatConstStrID) {
        assert(node->children.size() == 2);

        Constant* leftOp = evaluateConstantNode(&node->children[0]);
        Constant* rightOp = evaluateConstantNode(&node->children[1]);

        return new ConcatConstants(leftOp, rightOp);
    }
    else {
        throw ex::GeneratorException();
    }

}

IBoolExpression* SnippetFactory::evaluateBoolExpressionNode(tree_node<node_val_data<> >* node) {
    assert(node->value.id() == g.boolExpressionID);
    assert(node->children.size() == 2);

    IExpression* leftOp = evaluateNode(&node->children[0]);
    IExpression* rightOp = evaluateNode(&node->children[1]);

    return new BoolExpression(getValueOfNode(node), leftOp, rightOp);
}

/**
 * Transform AST from parser to GI internal AST
 */
IExpression* SnippetFactory::evaluateNode(tree_node<node_val_data<> >* node) {
    /**
     * Function Node
     * 1. child: identifier node of function to be called
     * 2. child: parameter list node
     */
    if (node->value.id() == g.functionID) {
        FunctionCall* f = new FunctionCall(getValueOfNode(&node->children[0]));

        if (node->children.size() == 2 && node->children[1].value.id() == g.paramlisteID) {
            for (unsigned int i = 0; i < node->children[1].children.size(); i += 2) {
                f->addParameter(evaluateNode(&node->children[1].children[i]));
            }
        }

        return f;
    }/**
     * StringLiteral
     */
    else if (node->value.id() == g.stringLiteralID) {
        std::string s = getValueOfNode(node);
        s = s.substr(1,s.size()-2);
        s = translateEscape(s);

        return Constant::createConstant(s);
    }/**
     * Integer Literal
     */
    else if (node->value.id() == g.intLiteralID) {
        std::stringstream ss;
        ss << getValueOfNode(node);
        int i = 0;
        ss >> i;
        return Constant::createConstant(i);
    }/**
     * variable
     */
    else if (node->value.id() == g.identifierID) {
        return new Variable(getValueOfNode(node));
    }/**
     * context variable
     */
    else if (node->value.id() == g.contextVarID) {
        return new Variable(getValueOfNode(node));
    }/**
     * function parameter access
     */
    else if (node->value.id() == g.funcParID) {
        return new FunctionParam(getValueOfNode(node));
    }/**
     * assignment operation
     */
    else if (node->value.id() == g.assignmentID) {
        return new Assignment(evaluateNode(&node->children[0]),
                evaluateNode(&node->children[1]));
    }/**
     * program node -> sequence
     */
    else if (node->value.id() == g.programID) {
        if (node->children.size() == 0) {
            return new NullOp();
        } else {
            Sequence* seq = new Sequence();
            for (unsigned int i = 0; i < node->children.size(); ++i) {
                seq->addStatement(evaluateNode(&node->children[i]));
            }
            return seq;
        }
    } else if (node->value.id() == g.conditionalID) {
        assert(node->children.size() == 2 || node->children.size() == 3);
        string relOp = getValueOfNode(&node->children[0]);

        IBoolExpression* boolExp = evaluateBoolExpressionNode(&node->children[0]); // evaluateNode(&node->children[0]);

        // IExpression* leftOp = evaluateNode(&node->children[0].children[0]);
        // IExpression* rightOp = evaluateNode(&node->children[0].children[1]);

        // expression if boolExp==true
        IExpression* tCode = evaluateNode(&node->children[1]);

        // check whether else {} is set
        if (node->children.size() == 3) {
            return new Conditional(boolExp, tCode, 0);
        } else {
            // expression if false
            IExpression* fCode = evaluateNode(&node->children[2]);

            return new Conditional(boolExp, tCode, fCode);
        }
    } else if (node->value.id() == g.termID) {
        assert(node->children.size() == 2);
        string op = getValueOfNode(node);

        IExpression* leftOp = evaluateNode(&node->children[0]);
        IExpression* rightOp = evaluateNode(&node->children[1]);

        return new Term(op, leftOp, rightOp);
    } else if (node->value.id() == g.concatConstStrID) {
        assert(node->children.size() == 2);

        Constant* leftOp = evaluateConstantNode(&node->children[0]);
        Constant* rightOp = evaluateConstantNode(&node->children[1]);

        return new ConcatConstants(leftOp, rightOp);
    } else if (node->value.id() == g.boolExpressionID) {

        // dublicated code from evaluateBoolExpression() which is necessary to deliver the BPatch_boolExp

        assert(node->children.size() == 2);

        IExpression* leftOp = evaluateNode(&node->children[0]);
        IExpression* rightOp = evaluateNode(&node->children[1]);

        return new BoolExpression(getValueOfNode(node), leftOp, rightOp);
    }

    return new NullOp();
}

SnippetFactory::SnippetFactory(codegrammar & g) : g(g) {

}

SnippetFactory::~SnippetFactory() {
}
